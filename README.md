## 프로젝트 개요
E-커머스 서비스로서 아래의 API를 제공합니다.
- 잔액 충전/조회 API
- 상품 조회 API
- 주문/결제 API
- 선착순 쿠폰 API
- 인기 판매 상품 API

---

## 요구사항 정리
### 기능적 요구사항

| 도메인 | 기능명         | 설명                                                                                                                |
|----|-------------|-------------------------------------------------------------------------------------------------------------------|
| 유저 | 포인트 조회      | 유저는 자신이 보유한 포인트를 조회할 수 있습니다                                                                                       |
| 유저 | 포인트 충전      | 유저는 상품 구매를 위한 포인트를 충전할 수 있습니다                                                                                     |
| 유저 | 포인트 사용      | 유저는 포인트를 사용하여 상품을 결제할 수 있습니다                                                                                      |
| 상품 | 상품 조회       | 특정 상품을 조회하여 이름, 가격, 수량을 확인할 수 있습니다                                                                                |
| 상품 | 전체 상품 조회    | 모든 상품을 조회하여 이름, 가격, 수량을 확인할 수 있습니다                                                                                |
| 상품 | 인기 판매 상품 조회 | 현재 일을 기준으로 최근 3일간 가장 많이 판매된 상품 N개를 조회할 수 있습니다                                                                     |
| 주문 | 상품 주문       | 유저는 아직 재고가 남아있는 상품을 주문할 수 있습니다                                                                                    |
| 주문 | 주문 조회       | 유저는 단건의 주문 내용을 조회하여 주문한 상품의 이름, 가격, 주문 수량과 주문 상태를 확인할 수 있습니다 <br/>주문 상태 종류 : [주문취소, 결제 전, 결제완료, 배송전, 배송중, 배송 완료] |
| 주문 | 전체 주문 조회    | 유저는 모든 주문의 내용을 조회하여 주문한 상품의 이름, 가격, 주문 수량과 주문 상태를 확인할 수 있습니다 <br/>주문 상태 종류 : [주문취소, 결제 전, 결제완료, 배송전, 배송중, 배송 완료]  |
| 주문 | 주문 취소       | 유저는 [결제 전, 결제 완료, 배송 전] 상태의 주문을 취소할 수 있습니다                                                                        |
| 결제 | 결제          | 유저는 취소되지 않은 주문을 포인트를 사용하여 결제를 요청할 수 있습니다                                                                          |
| 결제 | 결제 조회       | 유저는 주문의 결제 상태를 조회할 수 있습니다.. <br/>     결제 상태 종류: [결제 전, 결제 완료, 결제 취소]                                      |
| 쿠폰 | 쿠폰 조회       | 유저는 현재 자신이 사용할 수 있는 쿠폰을 조회할 수 있습니다 <br/>쿠폰 상태 종류: [발급됨, 사용됨]                                                      |
| 쿠폰 | 쿠폰 사용       | 유저는 쿠폰을 사용하여 할인된 금액으로 상품을 구매할 수 있습니다                                                                              |
| 쿠폰 | 선착순 쿠폰 발급   | 유저는 선착순으로 제공되는 쿠폰을 발급 받아 등록할 수 있습니다                                                                               |

### 비기능적 요구사항
* 선착순 쿠폰 발급로 인해 특정 시간대에 트래픽이 몰려 짧은 시간에 많은 요청이 들어오더라도 버틸수 있어야합니다.

---

## 아키텍처 설명
해당 프로젝트는 Clean Architecture
이번 과제는 Clean Architecture와 Facade를 사용하여 진행하였습니다.
<br> 도메인 기능 하나를 수행하는 UseCase들을 Facade에서 관리, 조합하는 방식으로 코드를 구현하였으며
<br> 각기 다른 도메인의 로직을 처리해야될 부분은 DomainService에서 처리를 하였습니다.
<br>
### 아키텍처 선택 이유
많은 사람들이 이미 널리 사용되고 있는 레이어드 아키텍처 대신 클린 아키텍처를 선택하는 이유에 대해 궁금증이 있었고,
UseCase를 하나의<br> 도메인 기능 단위로만 구성함으로써 SRP(단일 책임 원칙)를 철저히 준수하고,
외부 의존성을 최소화함으로써 애플리케이션의 범용성과 유지보수성을 크게 향상시킬 수 있다는 점에서
클린 아키텍처가 여러 측면에서 더 우수하다고 판단하였습니다.

## 계층 구조 및 특징
```
Controller -> UseCase -> DomainService(선택) -> Repositroy ->  RepositoryImpl(구현체)
```

### Controller
클라이언트로부터의 HTTP 요청을 받아 처리하는 계층입니다. 
<br> `@Valid`을 통해 requestDTO에서 검증을 진행하는 것이 특징입니다.

### Facade
여러 유스케이스를 관리 및 조합하여 기능을 구현하는 계층입니다.
<br> 이번 과제의 경우 주문, 결제, 선착순 쿠폰 발급 기능을 해당 계층에서 구현하였습니다.

### UseCase
한가지 기능 또는 목적에 집중된 서비스 계층 입니다.
<br> 여기서 말하는 한가지 기능은 도메인 기능을 기준으로 삼았으며 포인트 충전을 예시로 들면
<br> 포인트 충전, 포인트내역 등록은 하나의 도메인 기능으로서 유스케이스를 작성하였습니다.

### DomainService(선택)
여러 도메인 로직을 처리하는 도메인 계층입니다. 
<br> 앞서 언급드린대로 이름은 Service이지만 도메인 로직을 처리하는 로직입니다. 이번의 경우 쿠폰을 사용하는 유스케이스에서  <br> 
`쿠폰 사용 여부 확인`, `주문상세의 총금액 계산`, `쿠폰 상태 변경`을 하나의 도메인 서비스 로직으로 묶어서 처리하였습니다.

### Repositroy
도메인이 데이터 베이스 와 상호작용하기 위한 추상화된 계층입니다.
<br> 도메인이 데이터베이스 세부 구현에 의존하지 않도록 하여 결합도를 낮추고, 유연한 구조를 만듭니다.

### Repository(구현체)
RepositoryImpl은 Repository 인터페이스를 실제 데이터베이스 맞게 구현한 구체 클래스입니다.
<br> 인터페이스와 분리되어 있어 데이터 베이스 구현 및 변경 시 도메인이나 상위 계층에 영향을 최소화합니다.


```
### 도메인 구조의 패키지 구조를 선택한 이유
계층 구조의 패키지 구조를 선택하게 될 경우 여러 UseCase들을 한번에 파악하기 쉽다는 장점도 있지만
<br> 반대로 내가 원하는 도메인의 UseCase들을 찾는데에는 어려움이 있을 것이라고 생각하였습니다.
<br> 그리고 추후 도메인 별로 계층 구조가 달라지거나 특정 도메인에 추가적인 외부 의존성이 추가가 될 경우
<br> 패키지 구조를 도메인 구조로 하는 편이 클린 아키텍처와 DDD가 지향하는 바에 더욱 적합하다고 생각이 되었습니다.

## 클린 코드 작성을 위해 신경쓴 부분
#### - 도메인별로 상위 커스텀 예외를 정의하고, 그 하위에 세부 예외들을 계층적으로 구성했습니다.
이러한 구조는 각 도메인의 책임을 명확하게 분리하고, 예외 확장 시에도 변경 없이 쉽게 확장이 가능합니다.

<br>

#### - 입력 값 검증에 `@Valid`를 사용하였습니다.
`@Valid` 는 검증 로직을 컨트롤러나 서비스에서 진행하지 않고 DTO에서 진행함으로서 책임을 명확히 하였습니다.

<br>

### - `MapStruct`를 사용해 `DTO`와 도메인 객체 간 변환 로직을 변경하였습니다.
`ModelMapper`와 같이 `MapStruct`는 간단하게 객체간의 변환이 가능하여 중복된 코드 작성을 지양하게 됩니다.
<br> 이를 통해 변환 코드를 명확히 분리하고, 중복과 오류 가능성을 줄이며, 핵심 비즈니스 로직에 집중할 수 있게 되었습니다.
<br> +) `ModelMapper`는 비교적 간단하게 사용할 수 있지만 속도면에서 불리한 부분이 있기에 초기에는 `ModelMapper`로 작성하였지만
<br> 자주 사용되는 기능인 만큼 성능 상 이점이 있는 `MapStruct`로 리펙토링을 진행하였습니다. 

<br>

### - 디버깅 추격을 용이하기 위해 최소한의 `lombok`을 사용하였습니다.
도메인과 Entity, DTO에서는 코드의 가독성을 위해 `@Getter`와 `@Setter` 그리고 시간 여건상 `Builder`를 별도의 메서드로 만들지 못하여
<br> `@Builder` 이렇게 3가지의 lombok만을 사용하고 있습니다.

<br>

### - 전역 예외 처리(GlobalExceptionHandler)를 도입했습니다.
예외 처리 로직을 한 곳에 모아 책임을 분리하고, 중복 코드를 제거하며 일관된 에러 응답을 제공하였습니다.

<br>

#### - 테스트 클래스에 `@Nested`를 사용하였습니다.
`@Nested`는 상황, 기능 별로 계층화를 할 수 있으며 이번의 경우 성공과 실패 케이스를 계층화 하여 가독성을 향상 시켰습니다. 

<br>

#### - 테스트용 `Step` 클래스를 만들어 기본값이 설정된 객체 생성을 담당하게 했습니다
`Step` 클래스을 통해 테스트 코드의 중복을 줄이고, 가독성을 높이며, 테스트 목적을 명확하게 하였습니다.
<br> 또한, 테스트 데이터 준비 책임을 분리하여 테스트 코드의 유지보수성과 재사용성을 크게 개선하였습니다.



