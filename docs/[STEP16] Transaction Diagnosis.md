## [Step16] Transaction Diagnosis

- **도메인별로 트랜잭션이 분리되었을 때 발생 가능한 문제 파악**
- **트랜잭션이 분리되더라도 데이터 일관성을 보장할 수 있는 분산 트랜잭션 설계**

---

## 도메인별 트랜잭션 분리 시 발생 가능한 문제
- 도메인마다 서로 다른 DB를 사용하기 때문에, 여러 도메인이 포함된 로직에서는 단일 트랜잭션으로 원자성을 보장할 수 없습니다.
- Spring에서 제공하는 트랜잭션은 단일 데이터소스 기준으로만 동작하므로, 멀티 DB 또는 MSA 환경에서는 한계가 존재합니다.
- 이러한 상황을 해결하기 위해서는 분산 트랜잭션과 보상 트랜잭션을 처리하는 로직이 필요합니다.

## 분산 트랜잭션 설계
#### 도메인별로 트랜잭션이 분리될 경우, 원자성과 일관성을 보장하기 위해 필요한 것이 분산 트랜잭션입니다.

대표적인 분산 트랜잭션 구현 방법에는 2PC(2 Phase Commit)와 보상 트랜잭션 기반의 SAGA 패턴이 있습니다.  
하지만 2PC 기반 분산 트랜잭션은 성능 저하와 서비스 간 결합도가 높아지는 단점이 있어, 여기서는 SAGA 패턴 중심으로 다루겠습니다.

---

## SAGA 패턴의 종류
SAGA 패턴은 **Orchestration SAGA**와 **Choreography SAGA**로 나뉩니다.

### Choreography SAGA
- 메시지 브로커를 통해 이벤트를 교환하며 진행
- 각 서비스는 이벤트를 발행하고, 다른 서비스는 해당 이벤트를 구독하여 자신이 수행할 로직을 처리
- 장점: 서비스 간 결합도가 낮고 확장성이 뛰어남
- 단점: 이벤트 흐름 추적이 어렵고, 디버깅 및 모니터링이 복잡

> 각 서비스가 느슨하게 결합되어 있기 때문에, 이벤트 발행자와 구독자는 서로의 정보를 알 필요가 없습니다.

---

### Orchestration SAGA
- 중앙 오케스트레이터가 트랜잭션을 순서대로 실행하고, 실패 시 보상 트랜잭션을 호출
- 장점: 전체 프로세스 흐름이 중앙 집중적으로 관리되어 디버깅, 로깅, 모니터링이 용이
- 단점: 오케스트레이터와 서비스 간 결합도가 높고, 단일 장애점(SPOF, Single Point of Failure) 위험 존재

> 모든 Saga 트랜잭션의 순서, 상태, 실패 처리 로직이 오케스트레이터에 집중되어 있기 때문에, 오케스트레이터가 다운되거나 네트워크 장애가 발생하면 전체 분산 트랜잭션이 중단될 수 있습니다.

---

### SAGA 패턴별 장단점

| Saga 패턴 | 장점 | 단점 |
|-----------|------|------|
| **Choreography Saga** | 서비스 간 결합도가 낮고 확장성이 뛰어남 | 이벤트 흐름 추적 및 디버깅이 복잡 |
| **Orchestration Saga** | 중앙 관리로 흐름 제어 및 디버깅 용이 | 중앙 오케스트레이터 의존 증가, SPOF 가능성 |

---

### 추가 고려 사항
- **보상 트랜잭션 설계**
    - 실패 시 해당 작업을 되돌리는 추가 작업 필요 (단순 롤백이 아니며, 이력 기록 필수)
    - 예: 포인트 차감 성공 후 결제 실패 → 포인트 충전 API 호출
    - 보상 로직은 항상 **idempotent(멱등성)** 보장
- **에러 처리 및 재시도(Retry) 전략**
    - 네트워크 장애나 일시적 오류 발생 시 재시도 전략 필요
- **모니터링 전략**
    - Choreography SAGA의 경우 Spring Cloud Sleuth, AWS X-Ray 등으로 분산 트랜잭션 추적 가능

